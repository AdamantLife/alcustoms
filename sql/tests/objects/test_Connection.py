## Test Target
from alcustoms.sql.objects import Connection
## Test Framework
import unittest

## Testing Utilities
from alcustoms.sql.tests import utils

## Sister Modules
from alcustoms import sql
from alcustoms.sql import objects, Utilities
from alcustoms.sql.objects import Table, View


class DatabaseObjectCase(unittest.TestCase):
    """ Tests basic functionalities """
    def setUp(self):
        utils.setupconnection(self)
        return super().setUp()

    def test_gettable(self):
        """ Tests the gettable method of the Database Object. """
        testtable = self.connection.gettable("testtable")
        self.assertEqual(testtable.definition,utils.TESTTABLESQL)
        self.assertEqual(testtable,Table.Table(utils.TESTTABLESQL))

    def test_gettablebyid(self):
        """ Tests that tables can be gotten by id """
        utils.setupadditionaltables(self)
        with Utilities.temp_row_factory(self.connection,sql.dict_factory):
            tableresults = self.connection.execute("""SELECT rowid,tbl_name FROM sqlite_master WHERE type='table';""").fetchall()
        ## Ensure gettablebyid also sets row_factory
        self.connection.row_factory = objects.advancedrow_factory
        for table in tableresults:
            with self.subTest(table = table):
                result = self.connection.gettablebyid(table['rowid'])
                self.assertEqual(result.name, table['tbl_name'])
                self.assertFalse(result.row_factory is None)

    def test_validatetable(self):
        """ Tests that validatetable method succeeds on valid input """
        self.assertTrue(self.connection.validatetable(utils.gettesttableconstructor()))

    def test_validatetable_sameobj(self):
        """ Tests that validatetable method succeeds when given a Table generated by the database """
        self.assertTrue(self.connection.validatetable(self.connection.gettable("testtable")))

    def test_validatetable_bad_missing(self):
        """ Tests that validatetable method returns False when supplied a table not in the database """
        testtable = Table.TableConstructor("notatable",columns = [objects.Column("notaname",datatype="REAL"),objects.Column("notavalue",datatype="BLOB")])
        self.assertFalse(self.connection.validatetable(testtable))

    def test_validatetable_bad_different(self):
        """ Tests that validatetable method returns False when supplied with a table that is in the database, but whose structure is different than implemented. """
        testtable = Table.TableConstructor("testtable",columns = [objects.Column("notaname",datatype="REAL"),objects.Column("notavalue",datatype="BLOB")])
        self.assertFalse(self.connection.validatetable(testtable))

    def test_addtables_one(self):
        """ Tests that a single table can be successfully added using Database.addtables """
        testtable = Table.Table(utils.TESTTABLESQL2)
        success,fail = self.connection.addtables(testtable)
        ## Make sure method output is correct
        self.assertListEqual(success,[testtable,])
        self.assertListEqual(fail,[])
        ## Ensure table was ACTUALLY added (and not just stuck in the success column)
        self.assertTrue(self.connection.validatetable(testtable))

    def test_addtables_multiple(self):
        """ Tests adding multiple tables successfully via .addtables """
        testtable2 = Table.Table(utils.TESTTABLESQL2)
        testtable3 = Table.Table(utils.TESTTABLESQL3)
        testtables = [testtable2,testtable3]
        success,fail = self.connection.addtables(*testtables)
        ## Ensure tables were sccessfully added
        self.assertListEqual(success,testtables)
        self.assertListEqual(fail,[])
        ## Double-check that tables are properly in the database
        self.assertTrue(self.connection.validatetable(testtable2))
        self.assertTrue(self.connection.validatetable(testtable3))

    def test_removetable(self):
        """ Tests that remove table can remove a table based on its table name """
        tablename = "testtable"
        ## This will fail if the table was not already created (thus rendering this test invalid)
        self.connection.gettable(tablename)

        self.connection.removetable(tablename)
        self.assertFalse(Table.tableexists(self.connection,tablename))
        self.assertRaisesRegex(ValueError,"Table .* does not exist",self.connection.gettable,tablename)

    def test_removetable_bad(self):
        """ Tests that removetable does not accept various datatypes """
        for value in [int,False,120,3.14]:
            with self.subTest(value = value):
                self.assertRaisesRegex(TypeError,"tablename should be a string or Table instance",self.connection.removetable,value)

    def test_removetable_object(self):
        """ Tests that tables can be removed using Tables and Table Subclasses """
        for table in [self.connection.gettable("testtable"),
                      self.connection.getadvancedtable("testtable")]:
            with self.subTest(table = table):
                self.connection.removetable(table)
                self.assertFalse(Table.tableexists(self.connection,table))
                self.assertRaisesRegex(ValueError,"Table .* does not exist",self.connection.gettable,table)

    def test_database_tableexists(self):
        """ Makes sure that database.tableexists functions the same as the base sql.Table.tableexists function """
        ## Real table
        tablename = "testtable"
        ## This will fail automatically if table doesn't exist
        table = self.connection.gettable(tablename)
        self.assertEqual(self.connection.tableexists(tablename),Table.tableexists(self.connection,tablename))

        ## Fake Table
        tablename = "notarealtable"
        self.assertRaises(ValueError,self.connection.gettable,tablename)
        self.assertEqual(self.connection.tableexists(tablename),Table.tableexists(self.connection,tablename))

    def test_database_viewexists(self):
        """ Makes sure that database.viewexists functions the same as the base sql.View.viewexists function """
        self.connection.execute(utils.TESTVIEWSQL)
        ## Real view
        viewname = "testview"
        self.assertEqual(self.connection.viewexists(viewname),View.viewexists(self.connection,viewname))

        ## Fake Table
        viewname = "notarealview"
        ## TODO
        ## self.assertRaises(ValueError,self.connection.getview,tablename)
        self.assertEqual(self.connection.viewexists(viewname),View.viewexists(self.connection,viewname))

    def test_database_listconstructs(self):
        """ Tests that list constructs works """
        c = self.connection
        c.removetable("testtable")
        
        ## No Tables
        self.assertEqual(c.list_constructs(),[])

        ## One Table
        c.addtables(Table.Table(utils.TESTTABLESQL))
        self.assertEqual(c.list_constructs(),[utils.TESTTABLESQL,])

        ## Multiple Tables
        utils.setupadditionaltables(self)
        ## utils.setupadditionaltables sets self.testtables as a list of all presumed tables (testtable1 + tables added by utils.setupadditionaltables)
        ## sqlite_master doesn't save the ending ";" or "IF NOT EXISTS" clause
        self.assertEqual(c.list_constructs(), [table.definition.rstrip(";").replace("IF NOT EXISTS ","") for table in self.testtables])

        ## Remove a table
        c.removetable("testtable2")
        self.testtables.remove(Table.Table(utils.TESTTABLESQL2))
        self.assertEqual(c.list_constructs(), [table.definition.rstrip(";").replace("IF NOT EXISTS ","") for table in self.testtables])

        ## Add View
        ## TODO: Fix this to be addview
        c.execute(utils.TESTVIEWSQL)
        self.assertEqual(c.list_constructs(), [table.definition.rstrip(";").replace("IF NOT EXISTS ","") for table in self.testtables]+[utils.TESTVIEWSQL.rstrip(";"),])


class DatabaseObjectCase2(unittest.TestCase):
    """ Tests with additional table setup """
    def setUp(self):
        utils.setupconnection(self)
        utils.setupadditionaltables(self)
        return super().setUp()

    def test_getalltables_returntype(self):
        """ Tests that getalltables returns AdvancedTable instances """
        tables = self.connection.getalltables()
        self.assertTrue(tables)
        self.assertTrue(all(isinstance(table,Table.AdvancedTable) for table in tables))

    def test_addtables_exists(self):
        """ Tests that adding a table that already exists but has the "IF NOT EXISTS" tag succeeds """
        testtable4 = Table.Table(utils.TESTTABLESQL4)
        testtables = [testtable4,]
        success,fail = self.connection.addtables(*testtables)
        ## Ensure tables were sccessfully added
        self.assertListEqual(success,testtables)
        self.assertListEqual(fail,[])
        alltables = self.connection.getalltables()
        for table in testtables:
            with self.subTest(table = table,alltables = alltables):
                self.assertIn(table,alltables)
        ## Check the table is in the database
        self.assertTrue(self.connection.validatetable(testtable4))

    def test_addtables_exists_bad(self):
        """ Tests that adding a table that already exists and does not have the "IF NOT EXISTS" tag fails """
        testtable3 = Table.Table(utils.TESTTABLESQL3)
        testtables = [testtable3,]
        success,fail = self.connection.addtables(*testtables)
        ## Ensure tables were sccessfully added
        self.assertListEqual(success,[])
        self.assertListEqual(fail,testtables)

    def test_addandvalidatetables(self):
        """ Tests the basic functionality of addandvalidatetables """
        success,fail = self.connection.addandvalidatetables(*self.testtables)
        ## Should only succeed
        self.assertListEqual(success,self.testtables)
        self.assertListEqual(fail,[])

    def test_addandvalidatetables_addone(self):
        """ Tests that addandvalidatetables will correctly add and validate a table not in the database """
        testtable5 = Table.Table(utils.TESTTABLESQL5)
        success,fail = self.connection.addandvalidatetables(testtable5,*self.testtables)
        ## Should only succeed
        self.assertListEqual(success,[testtable5,]+self.testtables)
        self.assertListEqual(fail,[])
        ## Table should now exist
        self.assertTrue(self.connection.validatetable(testtable5))

    def test_addandvalidatetables_bad(self):
        """ Tests that addandvalidatetables will result in a failure when a table's definition is different from its version in the database """
        testtable = Table.TableConstructor("testtable",columns = dict(name="TEXT",value="FLOAT"))
        success,fail = self.connection.addandvalidatetables(testtable)
        ## Should only fail
        self.assertListEqual(success, [])
        self.assertListEqual(fail,[testtable,])
        ## Table in database should be different from testtable 
        self.assertFalse(self.connection.gettable("testtable") == testtable)

    def test_addandvalidatetables_mixed(self):
        """ Tests that addandvalidatetables will result in a failure when a table's definition is different from its version in the database, and success for tables that are added or are properly implemented """
        badtesttable = Table.TableConstructor("testtable",columns = dict(name="TEXT",value="FLOAT"))
        goodtesttable = Table.Table(utils.TESTTABLESQL5)
        testtables = self.testtables+[badtesttable,goodtesttable]
        success,fail = self.connection.addandvalidatetables(*testtables)
        ## Preexisting and good testtable should be in success
        self.assertListEqual(success, self.testtables+[goodtesttable,])
        ## The malformed table should be in fail
        self.assertListEqual(fail,[badtesttable,])

class DatabaseObjectCase3(unittest.TestCase):
    def setUp(self):
        utils.setupconnection(self)
        utils.setupadditionaltables(self)
        return super().setUp()

    class AdvancedTestTable(Table.AdvancedTable):
        test_true = True

    def test_advancedtable_constructor(self):
        """ Tests that the advancedtable constructor can be used to initiliaze tables """
        AdvancedTestTable = DatabaseObjectCase3.AdvancedTestTable

        ## Test with a dict
        self.connection.table_constructor = {"testtable": AdvancedTestTable}
        ## Test that testtable returns a different AdvancedTable subclass
        table = self.connection.getadvancedtable("testtable")
        self.assertIsInstance(table,AdvancedTestTable)
        self.assertTrue(table.test_true)
        ## Test that testtable2 doesn't return this subclass because 
        ## it's not part of the table_constructor
        table2 = self.connection.getadvancedtable("testtable2")
        self.assertNotIsInstance(table2,AdvancedTestTable)
        self.assertFalse(hasattr(table2,"test_true"))

        ## Test with a callable (function)
        def my_constructor(tablename):
            if tablename == "testtable3":
                return AdvancedTestTable
            return Table.AdvancedTable
        self.connection.table_constructor =  my_constructor
        ## Test that testtable3 returns a different AdvancedTable subclass
        table3 = self.connection.getadvancedtable("testtable3")
        self.assertIsInstance(table3,AdvancedTestTable)
        self.assertTrue(table3.test_true)
        ## Test that testtable4 doesn't return this subclass because 
        ## it's not part of the table_constructor
        table4 = self.connection.getadvancedtable("testtable4")
        self.assertNotIsInstance(table4,AdvancedTestTable)
        self.assertFalse(hasattr(table4,"test_true"))